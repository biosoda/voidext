<h2 id="desc" class="list">Extended Vocabulary of Interlinked Datasets (VoIDext): Description <span class="backlink"> back to <a href="#toc">ToC</a></span></h2>

<p>The complexity of quickly achieving semantic interoperability substantially increases when considering 
distributed and independent RDF datasets on the Web. The reasons for that can be summarized as follows:  
</p>
<ul>
 <li>Thanks to Semantic Web standards, large datasets are now machine-readable. Nevertheless, 
 just adopting these standards, like just using Web Ontology Language (OWL), does not
  eliminate semantic heterogeneity for good: it elevates heterogeneity problems at a higher level 
  (e.g. data schema).
  </li><li>Improving semantic interoperability with semantic reconciliation among RDF data publishers 
  is often not conceivable or requires fastidious and time-consuming efforts to have a consensus in 
  terms of data modelling decisions and semantic interpretations.  
  </li>  <li> RDF datasets can be published with incomplete or missing data schemas and they 
  frequently do not include how to semantically relate with other relevant third-party datasets. 
  This considerable harden the task of manually or automatically writing federated queries, for example,
   with SPARQL 1.1 query language.
    </li>
</ul>
<p>To mitigate the inherent difficulty of establishing semantic interoperability, we hereby propose a 
vocabulary and patterns to describe the semantic relations among datasets. This vocabulary so-called 
VoIDext is actually an extension and an adaptation of the well-accepted VoID RDF schema vocabulary. 
In this documentation, the words vocabulary and ontology are interchangeably used. The proposed VoID 
extension is a meta-ontology that describes semantic  links between RDF datasets - virtual links. 
</p>


<h3>Virtual links between RDF datasets</h3>


<p>An RDF dataset is ``a set of RDF triples that are published, maintained or aggregated by a single provider" 
according to the <a href="http://rdfs.org/ns/void">VoID specification</a>. RDF datasets are often  independent
 and distributed on the Web. A virtual link is a connection between common resources such as literals and
  instances from two  different RDF datasets. Semantic relaxation is also considered when identifying common 
   resources between datasets. For example, the datasets might use different prefix namespaces for similar 
   instances in a given domain scope.
</p>
<p> A virtual link can be interpreted as an intersection data point between two datasets. In addition,
 a virtual link is not explicitly and concretely stored. The link may be physically established, for example,
  during a conjunctive federated query execution. Virtual links can simply be predicates (i.e. relations) 
  in one dataset where subjects and objects of the triples are present in disparate datasets. The types of
   resources involved in a virtual link can be also a valuable information. Another type of virtual 
   link can be stated when two datasets share the same instances of a given type. These instances 
   usually do not have exactly the same description or context in each dataset.
</p>
<p> 
Moreover, distinct datasets can state different predicates with the same or similar subjects and objects. 
By considering these subjects and objects that are in common, the RDF graphs from these datasets may establish
 two types of intersection nodes (i.e. matched nodes): object-object, subject-subject, and subject-object. 
 For example, given the following RDF triples T<sub>a</sub> = (S<sub>a</sub>,P<sub>a</sub>, O<sub>a</sub>) in dataset "a" and 
  T<sub>b</sub>=(S<sub>b</sub>,P<sub>b</sub>, O<sub>b</sub>) in dataset b; if O<sub>a</sub> &equiv; O<sub>b</sub> then we can state a virtual link between
   O<sub>a</sub> and O<sub>b</sub>; and if S<sub>a</sub> &equiv; S<sub>a</sub> then we can state a virtual link between S<sub>a</sub> and S<sub>b</sub>; 
   and finally if S<sub>a</sub>&equiv; O<sub>b</sub> then we can state a virtual link between S<sub>a</sub> and O<sub>b</sub>. 
   The &equiv; symbol represents equivalent subjects or objects. One could also imagine the case of O<sub>a</sub>
    being similar to O<sub>b</sub> (i.e. O<sub>a</sub> \sim O<sub>b</sub>). In this case, a resource mapping function f<sub>m</sub>(r) is
     required to establish a virtual link between O<sub>a</sub> and O<sub>b</sub> --- i.e. O<sub>a</sub> &equiv; f<sub>m</sub>(O<sub>b</sub>) or f<sub>m</sub>(O<sub>a</sub>)
      &equiv; O<sub>b</sub>. This is due to the fact of existing heterogeneities in the representation of a resource 
      (e.g. "id:1234" or "id_1234" strings) and the resource description, for example, different set of
       predicates to contextualize a similar resource in different datasets and domain scopes. 
</p>

<p>Finally, we can also mention the fact of two separated datasets sharing the same instance IRIs, 
nevertheless they are asserted as instances of unlike classes (i.e. types). Yet, a virtual link can be 
stated between these instances. This fact might be because of distinct domain scopes and constraints such
 as legacy information systems. 
</p>
<p>Although the  examples in this specification are based on existing life sciences RDF datasets on the Web, 
<b>VoIDext can be applied to any knowledge domain</b>. The RDF data may be accessible through SPARQL endpoints.
 The considered datasets in this specification are as follows:
 <a href="https://omabrowser.org">OMA (Orthologous MAtrix)</a> , 
 <a href="https://uniprot.org">UniProtKB (UniProt Knowledgebase)</a>,
 <a href=""> Drugbank </a>,
 <a href="https://bgee.org"> Bgee (dataBase for Gene Expression Evolution)</a> , 
 and <a href="https://www.ebi.ac.uk/rdf">EBI (European Bioinformatics Institute) RDF platform </a>. 
 <a href="#tab_endpoints">Table 2</a> lists the SPARQL endpoints of these datasets.

</p>


<div id="ns" align="center">
<table id="tab_endpoints">
<caption> <a href="#ns"> Table 2</a>: SPARQL endpoints for the examples discussed in this specification.
 </caption>
<tbody>
<tr><td><b>RDF Dataset</b></td><td><b>SPARQL endpoint</b></td></tr>
<tr><td>OMA</td><td>https://sparql.omabrowser.org/sparql</td></tr>
<tr><td>UniProtKB</td><td>https://sparql.uniprot.org/sparql</td></tr>
<tr><td>Bgee</td><td>http://biosoda.expasy.org:8080/rdf4j-server/repositories/bgeelight</td></tr>
<tr><td>Drugbank</td><td>http://wifo5-04.informatik.uni-mannheim.de/drugbank/sparql</td></tr>
<tr><td>EBI RDF</td><td>https://www.ebi.ac.uk/rdf/services/sparql</td></tr>

</tbody>
</table>

</div>

<p id="ex1"><b>Example 1: directed link predicates between datasets.</b></p>

A dataset can contain property assertions involving IRIs which are also present in another dataset. These IRIs in common, 
that are referred as instances of a given class, often do not necessary have the same set of properties or context in 
different datasets, however they are frequently complementary. For example, let us consider the OMA and UniProt RDF datasets. 
<a href="#fig1">Fig. 1</a> illustrates a triple in OMA where the predicate is a cross-reference property 
(i.e. <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a>) that assigns as value an IRI in common with Uniprot. 
By considering this, a direct virtual link such as the one shown in <a href="#fig1">Fig. 1</a> can be stated where the subject of 
<a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> is described in OMA and 
the object is further depicted in UniProt. To find out if the virtual link exists, we need to know which dataset contains the triples 
with the <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> predicate and what is the another one with the triples' objects.
 In this example, the objects are further described in the UniProt RDF dataset. Yet, it is suitable to know what is the context of the 
<a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> predicate's object in UniProt. In this case, the UniProt IRI that is
 illustrated as a black circle in <a href="#fig1">Fig. 1</a> indeed refers to an instance of the 
 \textit{up:Protein} class in UniProt. Therefore, \textit{up:Protein} must be asserted as the range of the virtual link.
  Although in this example the virtual link's range and the <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> 
  property's range in OMA are the same, it is not always the case when establishing directed virtual links. 

<div  align="center">
<figure id="fig1">
<p><img src="images/fig1.png" class="imagedesc2"/>
<figcaption><a href="#fig1">Figure 1</a>. A directed virtual link predicate between OMA and UniProt datasets.</figcaption>
</figure>
</div>

The  <a href="https://www.w3.org/TR/turtle/">RDF 1.1 Turtle</a> serialisation of <a href="#ex1">Example 1</a> 
according to VoIDext vocabulary is defined <a href="#ex1_ttl">below</a>. 
When the virtual link is stated between the <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> subject in a first dataset (e.g. UniProtKB) and the subject/object of any other 
property different from r<a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> in a second dataset (e.g. OMA), the non-rdf:type property is the
the link predicate (e.g. <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> in  <a href="#fig1">Fig. 1</a>) and either its
 domain (<a href="#linkPredicateDomain">voidext:linkPredicateDomain</a>) or range (<a href="#linkPredicateRange">voidext:linkPredicateRange</a>) 
 must be the object of the <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> property in the first dataset.
 
<pre class="example" id="ex1_ttl">
 bioquery:OMA_UNIPROT_1 rdf:type void:Linkset;
             void:objectsTarget   bioquery:UNIPROT;
             void:subjectsTarget  bioquery:OMA;
             void:linkPredicate lscr:xrefUniprot;
             voidext:linkPredicateDomain orth:Protein;
             voidext:linkPredicateRange up:Protein;
             void:subset bioquery:OMA.
             
  bioquery:UNIPROT a void:Dataset;
    dcterms:title "The Universal Protein Resource (UniProt)";
    dcterms:description "High-quality and freely accessible resource of protein sequence and functional information.";
    void:sparqlEndpoint &lt;https://sparql.uniprot.org/sparql/&gt;;
    dcterms:modified "2018-11-01"^^xsd:date;
    foaf:homepage &lt;https://www.uniprot.org&gt;.  
  
  bioquery:OMA a void:Dataset;
    dcterms:title "Orthologous Matrix (OMA)";
    dcterms:description "RDF data extracted from OMA HDF5 file.";
    void:sparqlEndpoint &lt;https://sparql.omabrowser.org/sparql&gt;;
    dcterms:modified "2018-06-01"^^xsd:date;
    foaf:homepage &lt;https://omabrowser.org/&gt;.
 </pre>
 
<p>Once directed virtual links are serialised with triple patterns such as the example  <a href="#ex1_ttl">above</a>,
 we can answer the following question:</p>
 <p> <b>Question (1)</b>: which are the set of directed virtual links between two RDF datasets?</p> 
<p>To  answer this question, the SPARQL query template 1 (<a href="#q1">SQ<sub>1</sub></a>) below can be executed. For example, 
 we can retrieve the virtual link illustrated in <a href="#fig1">Fig. 1</a> by executing <a href="#q1">SQ<sub>1</sub></a> on the <a href="http://biosoda.expasy.org:8890/sparql">SPARQL endpoint here</a>. 
 </p>

<pre class="query" id="q1">
prefix void:    &lt;http://rdfs.org/ns/void#&gt;
prefix bioquery: &lt;http://purl.org/query/bioquery#&gt;
prefix voidext:&lt;http://purl.org/query/voidext#&gt;
prefix dcterms: &lt;http://purl.org/dc/terms/&gt;

SELECT distinct ?links  ?source  ?predicate_from_endpoint ?subj_from ?subj_type ?predicate 
 ?obj_type  ?obj_from  ?resourceMapping {

###if we want to specify the target datasets that contain one of the resources
###related with a virtual link.
#values(?dataset_link_subj){  (bioquery:OMA)  }
#values(?dataset_link_obj){  (bioquery:UNIPROT)  }

?links  a void:Linkset.
{
 ?links void:subjectsTarget ?dataset_link_subj .
 ?links void:objectsTarget ?dataset_link_obj.  
} UNION {
 ?links void:target ?dataset_link_subj.
 ?links void:target ?dataset_link_obj .}
 ?links void:linkPredicate ?predicate;
        void:subset ?source_db.
 ?dataset_link_subj void:sparqlEndpoint ?subj_from.
 ?dataset_link_obj void:sparqlEndpoint ?obj_from.
 ?source_db dcterms:title ?source;
            void:sparqlEndpoint ?predicate_from_endpoint.

 optional {?links  voidext:linkPredicateRange ?obj_type}.
 optional {?links voidext:linkPredicateDomain ?subj_type. }
 optional{ ?links voidext:resourceMapping  ?resourceMapping}

filter not exists { ?complexLink  voidext:intersectAt ?links.}       
filter ( ?dataset_link_subj  !=  ?dataset_link_obj )       

} order by ?links

#<a href="http://biosoda.expasy.org:8890/sparql?default-graph-uri=&query=prefix+void%3A++++%3Chttp%3A%2F%2Frdfs.org%2Fns%2Fvoid%23%3E%0D%0Aprefix+bioquery%3A+%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fbioquery%23%3E%0D%0Aprefix+voidext%3A%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fvoidext%23%3E%0D%0Aprefix+dcterms%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E%0D%0A%0D%0ASELECT+distinct+%3Flinks++%3Fsource++%3Fpredicate_from_endpoint+%3Fsubj_from+%3Fsubj_type+%3Fpredicate+%0D%0A+%3Fobj_type++%3Fobj_from++%3FresourceMapping+%7B%0D%0A%0D%0A%23%23%23if+we+want+to+specify+the+target+datasets+that+contain+one+of+the+resources%0D%0A%23%23%23related+with+a+virtual+link.%0D%0A%23values%28%3Fdataset_link_subj%29%7B++%28bioquery%3AOMA%29++%7D%0D%0A%23values%28%3Fdataset_link_obj%29%7B++%28bioquery%3AUNIPROT%29++%7D%0D%0A%0D%0A%3Flinks++a+void%3ALinkset.%0D%0A%7B%0D%0A+%3Flinks+void%3AsubjectsTarget+%3Fdataset_link_subj+.%0D%0A+%3Flinks+void%3AobjectsTarget+%3Fdataset_link_obj.++%0D%0A%7D+UNION+%7B%0D%0A+%3Flinks+void%3Atarget+%3Fdataset_link_subj.%0D%0A+%3Flinks+void%3Atarget+%3Fdataset_link_obj+.%7D%0D%0A+%3Flinks+void%3AlinkPredicate+%3Fpredicate%3B%0D%0A++++++++void%3Asubset+%3Fsource_db.%0D%0A+%3Fdataset_link_subj+void%3AsparqlEndpoint+%3Fsubj_from.%0D%0A+%3Fdataset_link_obj+void%3AsparqlEndpoint+%3Fobj_from.%0D%0A+%3Fsource_db+dcterms%3Atitle+%3Fsource%3B%0D%0A++++++++++++void%3AsparqlEndpoint+%3Fpredicate_from_endpoint.%0D%0A%0D%0A+optional+%7B%3Flinks++voidext%3AlinkPredicateRange+%3Fobj_type%7D.%0D%0A+optional+%7B%3Flinks+voidext%3AlinkPredicateDomain+%3Fsubj_type.+%7D%0D%0A+optional%7B+%3Flinks+voidext%3AresourceMapping++%3FresourceMapping%7D%0D%0A%0D%0Afilter+not+exists+%7B+%3FcomplexLink++voidext%3AintersectAt+%3Flinks.%7D+++++++%0D%0Afilter+%28+%3Fdataset_link_subj++%21%3D++%3Fdataset_link_obj+%29+++++++%0D%0A%0D%0A%7D+order+by+%3Flinks&should-sponge=&format=text%2Fhtml&timeout=0&debug=on"><b>Click here to execute this query over our exemplar dataset.</b></a>
 </pre>
<p> 
The outcome of this query is a set of tuples <i>T<sub>1</sub> = (?links, ?source, ?predicate_from_endpoint,
 ?subj_from, ?subj_type, ?predicate, ?obj_type,  ?obj_from  ?resourceMapping)</i> where <i>?links</i> is the direct virtual link IRI; <i>?source</i> is the 
 dataset source name where the link predicates are asserted; <i>?predicate_from_endpoint</i> is the access method to the link predicate assertions
  (e.g. an SPARQL endpoint); <i>?subj_from</i> is the access method to the link predicate' subject; <i>?subj_type</i> is the subject type;
   <i>?predicate</i> is the link predicate; <i>?obj_type</i> is the object type;  <i>?obj_from</i> is the access method to the link predicate's object;
    <i>?resourceMapping</i> is the resource mapping procedure, if any. 
    <i>?resourceMapping</i> must be applied to the <i> ?predicate</i> predicate' object in the dataset <i>?source</i> if <i>?predicate_from_endpoint &ne; ?obj_from</i>, 
    otherwise the mapping is applied to the <i>?predicate</i>' subject in <i>?source</i>. In addition, the  <i>?subj_type</i> xor <i>?obj_type</i> statements and the
     <i>?predicate</i> are in  different datasets (e.g. SPARQL enpoints) where "xor" is the "exclusive or".   <p>
<p>	One of this tuple could be as follows:  <i>T<sub>1</sub><sup>1</sup>=(bioquery:OMA_UNIPROT_1,  "Orthologous Matrix (OMA)", 
	&lt;https://sparql.omabrowser.org/sparql&gt;,  &lt;https://sparql.omabrowser.org/sparql&gt;,  orth:Protein, lscr:xrefUniprot, up:Protein,	 
	&lt;https://sparql.uniprot.org/sparql/&gt;, &Phi;)</i> where &Phi; represents an empty value. 
</p>
	