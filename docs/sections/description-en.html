<h2 id="desc" class="list">VoIDext Vocabulary: Description <span class="backlink"> back to <a href="#toc">ToC</a></span></h2>

<p>The complexity of quickly achieving semantic interoperability substantially increases when considering 
distributed and independent RDF datasets on the Web. The reasons for that can be summarized as follows:  
</p>
<ul>
 <li>Thanks to Semantic Web standards, large datasets are now machine-readable. Nevertheless, 
 just adopting these standards, like just using Web Ontology Language (OWL), does not
  eliminate semantic heterogeneity for good: it elevates heterogeneity problems at a higher level 
  (e.g. data schema).
  </li><li>Improving semantic interoperability with semantic reconciliation among RDF data publishers 
  is often not conceivable or requires fastidious and time-consuming efforts to have a consensus in 
  terms of data modelling decisions and semantic interpretations.  
  </li>  <li> RDF datasets can be published with incomplete or missing data schemas and they 
  frequently do not include how to semantically relate with other relevant third-party datasets. 
  This considerable harden the task of manually or automatically writing federated queries, for example,
   with SPARQL 1.1 query language.
    </li>
</ul>
<p>To mitigate the inherent difficulty of establishing semantic interoperability, we hereby propose a 
vocabulary and patterns to describe the semantic relations among datasets. This vocabulary so-called 
VoIDext is actually an extension and an adaptation of the well-accepted VoID RDF schema vocabulary. 
In this documentation, the words vocabulary and ontology are interchangeably used. The proposed VoID 
extension is a meta-ontology that describes semantic  links between RDF datasets - virtual links. 
</p>


<h3 id="desc_vl" class="list">Virtual links between RDF datasets <span class="backlink"> back to <a href="#toc">ToC</a></span></h3>


<p>An RDF dataset is "a set of RDF triples that are published, maintained or aggregated by a single provider" 
according to the <a href="http://rdfs.org/ns/void">VoID specification</a>. RDF datasets are often  independent
 and distributed on the Web. A virtual link is a connection between common resources such as literals and
  instances from two  different RDF datasets. Semantic relaxation is also considered when identifying common 
   resources between datasets. For example, the datasets might use different prefix namespaces for similar 
   instances in a given domain scope.
</p>
<p> A virtual link can be interpreted as an intersection data point between two datasets. In addition,
 a virtual link is not explicitly and concretely stored. The link may be physically established, for example,
  during a conjunctive federated query execution. Virtual links can simply be predicates (i.e. relations) 
  in one dataset where subjects and objects of the triples are present in disparate datasets. The types of
   resources involved in a virtual link can be also a valuable information. Another type of virtual 
   link can be stated when two datasets share the same instances of a given type. These instances 
   usually do not have exactly the same description or context in each dataset.
</p>
<p> 
Moreover, distinct datasets can state different predicates with the same or similar subjects and objects. 
By considering these subjects and objects that are in common, the RDF graphs from these datasets may establish
 two types of intersection nodes (i.e. matched nodes): object-object, subject-subject, and subject-object. 
 For example, given the following RDF triples T<sub>a</sub> = (S<sub>a</sub>,P<sub>a</sub>, O<sub>a</sub>) in dataset "a" and 
  T<sub>b</sub>=(S<sub>b</sub>,P<sub>b</sub>, O<sub>b</sub>) in dataset b; if O<sub>a</sub> &equiv; O<sub>b</sub> then we can state a virtual link between
   O<sub>a</sub> and O<sub>b</sub&gt;; and if S<sub>a</sub> &equiv; S<sub>a</sub> then we can state a virtual link between S<sub>a</sub> and S<sub>b</sub&gt;; 
   and finally if S<sub>a</sub>&equiv; O<sub>b</sub> then we can state a virtual link between S<sub>a</sub> and O<sub>b</sub>. 
   The &equiv; symbol represents equivalent subjects or objects. One could also imagine the case of O<sub>a</sub>
    being similar to O<sub>b</sub> (i.e. O<sub>a</sub> &sim; O<sub>b</sub>). In this case, a resource mapping function f<sub>m</sub>(r) is
     required to establish a virtual link between O<sub>a</sub> and O<sub>b</sub> --- i.e. O<sub>a</sub> &equiv; f<sub>m</sub>(O<sub>b</sub>) or f<sub>m</sub>(O<sub>a</sub>)
      &equiv; O<sub>b</sub>. This is due to the fact of existing heterogeneities in the representation of a resource 
      (e.g. "id:1234" or "id_1234" strings) and the resource description, for example, different set of
       predicates to contextualize a similar resource in different datasets and domain scopes. 
</p>

<p>Finally, we can also mention the fact of two separated datasets sharing the same instance IRIs, 
nevertheless they are asserted as instances of unlike classes (i.e. types). Yet, a virtual link can be 
stated between these instances. This fact might be because of distinct domain scopes and constraints such
 as legacy information systems. 
</p>
<p>Although the  examples in this specification are based on existing life sciences RDF datasets on the Web, 
<b>VoIDext can be applied to any knowledge domain</b>. The RDF data may be accessible through SPARQL endpoints.
 The considered datasets in this specification are as follows:
 <a href="https://omabrowser.org">OMA (Orthologous MAtrix)</a> , 
 <a href="https://uniprot.org">UniProtKB (UniProt Knowledgebase)</a>,
 <a href=""> Drugbank </a>,
 <a href="https://bgee.org"> Bgee (dataBase for Gene Expression Evolution)</a> , 
 and <a href="https://www.ebi.ac.uk/rdf">EBI (European Bioinformatics Institute) RDF platform </a>. 
 <a href="#tab_endpoints">Table 2</a> lists the SPARQL endpoints of these datasets.

</p>


<div id="ns" align="center">
<table id="tab_endpoints">
<caption> <a href="#ns"> Table 2</a>: SPARQL endpoints for the examples discussed in this specification.
 </caption>
<tbody>
<tr><td><b>RDF Dataset</b></td><td><b>SPARQL endpoint</b></td></tr>
<tr><td>OMA</td><td>https://sparql.omabrowser.org/sparql</td></tr>
<tr><td>UniProtKB</td><td>https://sparql.uniprot.org/sparql</td></tr>
<tr><td>Bgee</td><td>http://biosoda.expasy.org:8080/rdf4j-server/repositories/bgeelight</td></tr>
<tr><td>Drugbank</td><td>http://wifo5-04.informatik.uni-mannheim.de/drugbank/sparql</td></tr>
<tr><td>EBI RDF</td><td>https://www.ebi.ac.uk/rdf/services/sparql</td></tr>

</tbody>
</table>

</div>

<p>A virtual link (VL) can be classified as simple or complex. A simple VL must contain in its definition, 
either exactly one link predicate such as in <a href="#ex1_ttl">Example 1</a> or exactly one shared instance type (i.e. class).
This VL type is defined with the <a href="#SimpleLinkSet">voidext:SimpleLinkSet<a> subclasses.
A complex virtual link is composed of exactly either two link predicates (e.g. <a href="#ex1_ttl">Example 4</a>)  or two shared instance types (e.g. <a href="#ex1_ttl">Example 3</a>) . 
This VL type is defined with <a href="#ComplexLinkSet">voidext:ComplexLinkSet<a> class.
</p>
	

<h4 id="ex1" class="list">Example 1: directed link predicates between datasets. <span class="backlink"> back to <a href="#toc">ToC</a></span></h4>

A dataset can contain property assertions involving IRIs which are also present in another dataset. These IRIs in common, 
that are referred as instances of a given class, often do not necessary have the same set of properties or context in 
different datasets, however they are frequently complementary. For example, let us consider the OMA and UniProt RDF datasets. 
<a href="#fig1">Fig. 1</a> illustrates a triple in OMA where the predicate is a cross-reference property 
(i.e. <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a>) that assigns as value an IRI in common with Uniprot. 
By considering this, a direct virtual link such as the one shown in <a href="#fig1">Fig. 1</a> can be stated where the subject of 
<a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> is described in OMA and 
the object is further depicted in UniProt. To find out if the virtual link exists, we need to know which dataset contains the triples 
with the <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> predicate and what is the another one with the triples' objects.
 In this example, the objects are further described in the UniProt RDF dataset. Yet, it is suitable to know what is the context of the 
<a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> predicate's object in UniProt. In this case, the UniProt IRI that is
 illustrated as a black circle in <a href="#fig1">Fig. 1</a> indeed refers to an instance of the 
 <a href="https://www.uniprot.org/core/Protein">up:Protein</a> class in UniProt. Therefore, <a href="https://www.uniprot.org/core/">up:Protein</a> must be asserted as the range of the virtual link.
  Although in this example the virtual link's range and the <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> 
  property's range in OMA are the same, it is not always the case when establishing directed virtual links. 

<div  align="center">
<figure id="fig1">
<p><img src="images/fig1.png" class="imagedesc2"/>
<figcaption><a href="#fig1">Figure 1</a>. A directed virtual link predicate between OMA and UniProt datasets.</figcaption>
</figure>
</div>

The  <a href="https://www.w3.org/TR/turtle/">RDF 1.1 Turtle</a> serialisation of <a href="#ex1">Example 1</a> 
according to VoIDext vocabulary is defined <a href="#ex1_ttl">below</a>. 
When the virtual link is stated between the <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> subject in a first dataset (e.g. UniProtKB) and the subject/object of any other 
property different from <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> in a second dataset (e.g. OMA), the non-rdf:type property is the
the link predicate (e.g. <a href="http://purl.org/lscr#xrefUniprot">lscr:xrefUniprot</a> in  <a href="#fig1">Fig. 1</a>) and either its
 domain (<a href="#linkPredicateDomain">voidext:linkPredicateDomain</a>) or range (<a href="#linkPredicateRange">voidext:linkPredicateRange</a>) 
 must be the object of the <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> property in the first dataset.
 <div>
<pre class="example" id="ex1_ttl">
 bioquery:OMA_UNIPROT_1 rdf:type void:Linkset;
             void:objectsTarget   bioquery:UNIPROT;
             void:subjectsTarget  bioquery:OMA;
             void:linkPredicate lscr:xrefUniprot;
             voidext:linkPredicateDomain orth:Protein;
             voidext:linkPredicateRange up:Protein;
             void:subset bioquery:OMA.
             
  bioquery:UNIPROT a void:Dataset;
    dcterms:title "The Universal Protein Resource (UniProt)";
    dcterms:description "High-quality and freely accessible resource of protein sequence and functional information.";
    void:sparqlEndpoint &lt;https://sparql.uniprot.org/sparql/&gt;;
    dcterms:modified "2018-11-01"^^xsd:date;
    foaf:homepage &lt;https://www.uniprot.org&gt;.  
  
  bioquery:OMA a void:Dataset;
    dcterms:title "Orthologous Matrix (OMA)";
    dcterms:description "RDF data extracted from OMA HDF5 file.";
    void:sparqlEndpoint &lt;https://sparql.omabrowser.org/sparql&gt;;
    dcterms:modified "2018-06-01"^^xsd:date;
    foaf:homepage &lt;https://omabrowser.org/&gt;.
 </pre>
</div> 
<p>
In <a href="#ex1_ttl">Example 1</a>, the void:subjectsTarget and void:objectsTarget properties define the subject-object direction of the links explicitly 
	as described in the <a href="https://www.w3.org/TR/void/#target">VoID RDF schema vocabulary specification</a>. 
In addition, the void:subset property states which dataset contains the link predicate assertions.   
</p>
<p>Once directed virtual links are serialised with triple patterns such as the example  <a href="#ex1_ttl">above</a>,
 we can answer the following question:</p>
 <p> <b>Question (1)</b>: which are the set of directed virtual links between two RDF datasets?</p> 
<p>To  answer this question, the SPARQL query template 1 (<a href="#q1">SQ<sub>1</sub></a>) below can be executed. For example, 
 we can retrieve the virtual link illustrated in <a href="#fig1">Fig. 1</a> by executing <a href="#q1">SQ<sub>1</sub></a> on the <a href="http://biosoda.expasy.org:8890/sparql">SPARQL endpoint here</a>. 
 </p>

<pre class="query" id="q1">
prefix void:    &lt;http://rdfs.org/ns/void#&gt;
prefix bioquery: &lt;http://purl.org/query/bioquery#&gt;
prefix voidext:&lt;http://purl.org/query/voidext#&gt;
prefix dcterms: &lt;http://purl.org/dc/terms/&gt;

SELECT distinct ?links  ?source  ?predicate_from_endpoint ?subj_from ?subj_type ?predicate 
 ?obj_type  ?obj_from  ?resourceMapping {

###if we want to specify the target datasets that contain one of the resources
###related with a virtual link.
#values(?dataset_link_subj){  (bioquery:OMA)  }
#values(?dataset_link_obj){  (bioquery:UNIPROT)  }

?links  a void:Linkset.
{
 ?links void:subjectsTarget ?dataset_link_subj .
 ?links void:objectsTarget ?dataset_link_obj.  
} UNION {
 ?links void:target ?dataset_link_subj.
 ?links void:target ?dataset_link_obj .}
 ?links void:linkPredicate ?predicate;
        void:subset ?source_db.
 ?dataset_link_subj void:sparqlEndpoint ?subj_from.
 ?dataset_link_obj void:sparqlEndpoint ?obj_from.
 ?source_db dcterms:title ?source;
            void:sparqlEndpoint ?predicate_from_endpoint.

 optional {?links  voidext:linkPredicateRange ?obj_type}.
 optional {?links voidext:linkPredicateDomain ?subj_type. }
 optional{ ?links voidext:resourceMapping  ?resourceMapping}

filter not exists { ?complexLink  voidext:intersectAt ?links.}       
filter ( ?dataset_link_subj  !=  ?dataset_link_obj )       

} order by ?links

#<a href="http://biosoda.expasy.org:8890/sparql?default-graph-uri=&query=prefix+void%3A++++%3Chttp%3A%2F%2Frdfs.org%2Fns%2Fvoid%23%3E%0D%0Aprefix+bioquery%3A+%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fbioquery%23%3E%0D%0Aprefix+voidext%3A%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fvoidext%23%3E%0D%0Aprefix+dcterms%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E%0D%0A%0D%0ASELECT+distinct+%3Flinks++%3Fsource++%3Fpredicate_from_endpoint+%3Fsubj_from+%3Fsubj_type+%3Fpredicate+%0D%0A+%3Fobj_type++%3Fobj_from++%3FresourceMapping+%7B%0D%0A%0D%0A%23%23%23if+we+want+to+specify+the+target+datasets+that+contain+one+of+the+resources%0D%0A%23%23%23related+with+a+virtual+link.%0D%0A%23values%28%3Fdataset_link_subj%29%7B++%28bioquery%3AOMA%29++%7D%0D%0A%23values%28%3Fdataset_link_obj%29%7B++%28bioquery%3AUNIPROT%29++%7D%0D%0A%0D%0A%3Flinks++a+void%3ALinkset.%0D%0A%7B%0D%0A+%3Flinks+void%3AsubjectsTarget+%3Fdataset_link_subj+.%0D%0A+%3Flinks+void%3AobjectsTarget+%3Fdataset_link_obj.++%0D%0A%7D+UNION+%7B%0D%0A+%3Flinks+void%3Atarget+%3Fdataset_link_subj.%0D%0A+%3Flinks+void%3Atarget+%3Fdataset_link_obj+.%7D%0D%0A+%3Flinks+void%3AlinkPredicate+%3Fpredicate%3B%0D%0A++++++++void%3Asubset+%3Fsource_db.%0D%0A+%3Fdataset_link_subj+void%3AsparqlEndpoint+%3Fsubj_from.%0D%0A+%3Fdataset_link_obj+void%3AsparqlEndpoint+%3Fobj_from.%0D%0A+%3Fsource_db+dcterms%3Atitle+%3Fsource%3B%0D%0A++++++++++++void%3AsparqlEndpoint+%3Fpredicate_from_endpoint.%0D%0A%0D%0A+optional+%7B%3Flinks++voidext%3AlinkPredicateRange+%3Fobj_type%7D.%0D%0A+optional+%7B%3Flinks+voidext%3AlinkPredicateDomain+%3Fsubj_type.+%7D%0D%0A+optional%7B+%3Flinks+voidext%3AresourceMapping++%3FresourceMapping%7D%0D%0A%0D%0Afilter+not+exists+%7B+%3FcomplexLink++voidext%3AintersectAt+%3Flinks.%7D+++++++%0D%0Afilter+%28+%3Fdataset_link_subj++%21%3D++%3Fdataset_link_obj+%29+++++++%0D%0A%0D%0A%7D+order+by+%3Flinks&should-sponge=&format=text%2Fhtml&timeout=0&debug=on"><b>Click here to execute this query over our exemplar dataset.</b></a>
 </pre>
<p> 
The outcome of this query is a set of tuples <i>T<sub>1</sub> = (?links, ?source, ?predicate_from_endpoint,
 ?subj_from, ?subj_type, ?predicate, ?obj_type,  ?obj_from  ?resourceMapping)</i> where <i>?links</i> is the direct virtual link IRI; <i>?source</i> is the 
 dataset source name where the link predicates are asserted; <i>?predicate_from_endpoint</i> is the access method to the link predicate assertions
  (e.g. an SPARQL endpoint); <i>?subj_from</i> is the access method to the link predicate' subject; <i>?subj_type</i> is the subject type;
   <i>?predicate</i> is the link predicate; <i>?obj_type</i> is the object type;  <i>?obj_from</i> is the access method to the link predicate's object;
    <i>?resourceMapping</i> is the resource mapping procedure, if any. 
    <i>?resourceMapping</i> must be applied to the <i> ?predicate</i> predicate' object in the dataset <i>?source</i> if <i>?predicate_from_endpoint &ne; ?obj_from</i>, 
    otherwise the mapping is applied to the <i>?predicate</i>' subject in <i>?source</i>. In addition, the  <i>?subj_type</i> xor <i>?obj_type</i> statements and the
     <i>?predicate</i> are in  different datasets (e.g. SPARQL enpoints) where "xor" is the "exclusive or".   <p>
<p>	One of this tuple could be as follows:  <i>T<sub>1</sub><sup>1</sup>=(bioquery:OMA_UNIPROT_1,  "Orthologous Matrix (OMA)", 
	&lt;https://sparql.omabrowser.org/sparql&gt;,  &lt;https://sparql.omabrowser.org/sparql&gt;,  orth:Protein, lscr:xrefUniprot, up:Protein,	 
	&lt;https://sparql.uniprot.org/sparql/&gt;, &Phi;)</i> where &Phi; represents an empty value. 
</p>

<p id="ex2"><b>Example 2: equivalent instances between datasets</b></p>

<p>
OMA and UniProt RDF data stores have the same instance IRIs of the same class (namely <a href="https://www.uniprot.org/core/Taxon">up:Taxon</a>)to represent the organism species, however UniProtKB contains more information related
to taxonomic lineage for organisms when compared to OMA. Thus, these two datasets can be bridged by establishing a virtual link between the instances in common. In other words,
between the subject of the rdf:type property stated in each dataset. To do so, we can serialise in <a href="https://www.w3.org/TR/turtle/">RDF 1.1 Turtle</a>
 this simple virtual link as below (<a href="ex2_ttl">Example 2</a>).
</p>


 
<pre class="example" id="ex2_ttl">
bioquery:OMA_UNIPROT_3 a voidext:SharedInstanceSet;
             void:target bioquery:OMA;
             void:target bioquery:UNIPROT;
             voidext:sharedInstanceType up:Taxon.
 </pre>
 
 
<p>Once virtual links between instances are serialised with triple patterns such as the example  <a href="#ex2_ttl">above</a>,
 we can answer the following question:</p>
 <p> <b>Question (2)</b>: which are the set of virtual links between two shared instances of the same class in different RDF datasets?</p> 
<p>To  answer this question, the SPARQL query template 2 (<a href="#q2">SQ<sub>2</sub></a>) below can be executed. For example, 
 we can retrieve the virtual link between equivalent up:Taxon instances in both datasets by executing <a href="#q2">SQ<sub>2</sub></a>
  on the <a href="http://biosoda.expasy.org:8890/sparql">SPARQL endpoint here</a>. 
 </p>

<pre class="query" id="q2">
prefix void:    &lt;http://rdfs.org/ns/void#&gt;
prefix bioquery: &lt;http://purl.org/query/bioquery#&gt;
prefix voidext:&lt;http://purl.org/query/voidext#&gt;
prefix dcterms: &lt;http://purl.org/dc/terms/&gt;

SELECT distinct ?links ?dataset1_name  ?dataset2_name  ?sharedType  
                       ?dataset1_endpoint ?dataset2_endpoint {
  
 #values(?dataset1){ (bioquery:BGEE) }
 #values(?dataset2){ (bioquery:OMA) }

?links a voidext:SharedInstanceSet.
?links void:target ?dataset1.
?links void:target ?dataset2.
?links voidext:sharedInstanceType ?sharedType. 
?dataset1   dcterms:title ?dataset1_name;
                   void:sparqlEndpoint ?dataset1_endpoint.
?dataset2  dcterms:title ?dataset2_name;
                   void:sparqlEndpoint ?dataset2_endpoint.

filter not exists { ?complexLink voidext:intersectAt ?links .}  
filter(?dataset1 != ?dataset2)                     
} order by ?links

<a href="http://biosoda.expasy.org:8890/sparql?default-graph-uri=&query=prefix+void%3A++++%3Chttp%3A%2F%2Frdfs.org%2Fns%2Fvoid%23%3E%0D%0Aprefix+bioquery%3A+%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fbioquery%23%3E%0D%0Aprefix+voidext%3A%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fvoidext%23%3E%0D%0Aprefix+dcterms%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E%0D%0A%0D%0ASELECT+distinct+%3Flinks+%3Fdataset1_name++%3Fdataset2_name++%3FsharedType++%3Fdataset1_endpoint+%3Fdataset2_endpoint+%7B%0D%0A++%0D%0A+%23values%28%3Fdataset1%29%7B+%28bioquery%3ABGEE%29+%7D%0D%0A+%23values%28%3Fdataset2%29%7B+%28bioquery%3AOMA%29+%7D%0D%0A%0D%0A%3Flinks+a+voidext%3ASharedInstanceSet.%0D%0A%3Flinks+void%3Atarget+%3Fdataset1.%0D%0A%3Flinks+void%3Atarget+%3Fdataset2.%0D%0A%3Flinks+voidext%3AsharedInstanceType+%3FsharedType.+%0D%0A%3Fdataset1+++dcterms%3Atitle+%3Fdataset1_name%3B%0D%0A+++++++++++++++++++void%3AsparqlEndpoint+%3Fdataset1_endpoint.%0D%0A%3Fdataset2++dcterms%3Atitle+%3Fdataset2_name%3B%0D%0A+++++++++++++++++++void%3AsparqlEndpoint+%3Fdataset2_endpoint.%0D%0A%0D%0Afilter+not+exists+%7B+%3FcomplexLink+voidext%3AintersectAt+%3Flinks+.%7D++%0D%0Afilter%28%3Fdataset1+%21%3D+%3Fdataset2%29+++++++++++++++++++++%0D%0A%7D+order+by+%3Flinks%0D%0A&should-sponge=&format=text%2Fhtml&timeout=0&debug=on"><b>Click here to execute this query over our exemplar dataset.</b></a>
 </pre>
<p> 

<p>Indeed, the answer to the Question 2 is a set of tuples T<sub>2</sub> = (<i>?links</i>, <i>?dataset1_name</i>, <i>?dataset2_name</i>, 
 <i>?sharedType</i>, <i>?dataset1_endpoint</i>, <i>?dataset2_endpoint</i>) where <i>?links</i> is the virtual link IRI; 
 <i>?dataset1_name</i> and <i>?dataset2_name</i> are the name of the datasets that contain the instance IRIs in common;
  <i>?sharedType</i> is the type of the instances in common;  <i>?dataset1_endpoint</i> and <i>?dataset2_endpoint</i> 
  are the access methods such as SPARQL endpoints to the <i>?dataset1_name</i> and <i>?dataset2_name</i> datasets, respectively. For example,
  T<sub>2</sub><sup>1</sup> = (
	bioquery:OMA_BGEE_2, "Bgee - a database of gene expression",
	"Orthologous Matrix (OMA)", up:Taxon,  &lt;http://biosoda.cloudlab.zhaw.ch:8080/rdf4j-server/repositories/bgeelight&gt;, 
	&lt;https://sparql.omabrowser.org/sparql&gt; ).
	
</p>

<p id="ex3"><b>Example 3: similar instances between datasets</b></p>

<p>
EBI and UniProt RDF data stores use different instance IRIs and classes to represent the organism species, and in a more general way, the taxonomic lineage for organisms. 
To exemplify this, let us consider the <i>&lt;http://identifiers.org/taxonomy/9606&gt;</i> instance of <i>biopax:BioSource</i> and the 
<i>&lt;http://purl.uniprot.org/taxonomy/9606&gt;</i> instance of <a href="https://www.uniprot.org/core/Taxon">up:Taxon</a> in EBI and UniProt datasets,
 respectively. Although these instances are not exactly the same (i.e. distinct IRIs, property sets, and contexts), they refer to the same 
 organism species at some extent, namely <i>homo sapiens</i> --- human. By applying a semantic relaxation, we can state a virtual link
  between these two instances. This link is illustrated in <a href="#fig3">Fig. 2</a>. To establish this link, we need to define an IRI mapping function 
  (i.e. <i>f<sub>m</sub>(r)</i>) either to the EBI or UniProt species-related instances ---  either f<sub>m</sub>(<i>&lt;http://identifiers.org/taxonomy/9606&gt;</i>) 
  &equiv; <i>&lt;http://purl.uniprot.org/taxonomy/9606&gt;</i> or f<sub>m</sub>(<i>&lt;http://identifiers.org/taxonomy/9606&gt;</i>) 
  &equiv; <i>&lt;http://identifiers.org/taxonomy/9606&gt;</i>.   

</p>

<div  align="center">
<figure id="fig3">
<p><img src="images/fig2.png" class="imagedesc2"/>
<figcaption><a href="#fig3">Figure 2</a>. A virtual link between datasets based on similar IRIs of different types.</figcaption>
</figure>
</div>

The  <a href="https://www.w3.org/TR/turtle/">RDF 1.1 Turtle</a> serialisation of <a href="#ex3">Example 3</a> 
according to VoIDext vocabulary is defined <a href="#ex3_ttl">below</a>. 
When the virtual link is stated between the <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> subject in a first dataset (e.g. EBI) and the 
<a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> subject from a second dataset (e.g. UniProtKB), and if the instances are from different 
types such as illustrated in <a href="#fig3">Fig. 2</a>), we classify this virtual link as a <a href="#ComplexLinkSet">complex link set</a>. 
 
<pre class="example" id="ex3_ttl">
bioquery:EBI_UNIPROT_10 a voidext:SharedInstanceSet;
             void:target bioquery:EBI;
             void:target bioquery:UNIPROT;
             void:subset bioquery:EBI;
             voidext:resourceMapping 
             '''?IRI_EBI a &lt;http://www.biopax.org/release/biopax-level3.owl#BioSource&gt;.
                BIND(IRI(CONCAT("http://purl.uniprot.org/taxonomy/",
                STRAFTER(STR(?IRI_EBI),"http://identifiers.org/taxonomy/"))) as ?IRI_UNIPROT)
                FILTER(STRSTARTS(STR(?IRI_EBI),"http://identifiers.org/taxonomy/"))''';
             voidext:sharedInstanceType biopax:BioSource.

bioquery:EBI_UNIPROT_11 a voidext:SharedInstanceSet;
             void:target bioquery:EBI;
             void:target bioquery:UNIPROT;
             void:subset bioquery:UNIPROT;
             voidext:resourceMapping 
             '''?IRI_UNIPROT a &lt;http://purl.uniprot.org/core/Taxon&gt;.
                BIND(IRI(CONCAT("http://identifiers.org/taxonomy/",
                STRAFTER(STR(?IRI_UNIPROT),"http://purl.uniprot.org/taxonomy/"))) as ?IRI_EBI)
                FILTER(STRSTARTS(STR(?IRI_UNIPROT),"http://purl.uniprot.org/taxonomy/"))''';
             voidext:sharedInstanceType up:Taxon . 
             
bioquery:EBI_UNIPROT_12 a voidext:ComplexLinkSet;
             rdfs:comment "A virtual link between EBI and UniProt that share similar organism taxonomy instances. 
                             Being UniProt the most complete in terms of organism taxonomy in RDF.";
             void:target bioquery:EBI;
             void:target bioquery:UNIPROT;
             voidext:intersectAt bioquery:EBI_UNIPROT_11 ;
			 voidext:intersectAt bioquery:EBI_UNIPROT_10 ; 
			 voidext:recommendedMapping bioquery:EBI_UNIPROT_10 .  

bioquery:EBI a void:Dataset.
 </pre>
 
	
 
<p>Once virtual links between instances are serialised with triple patterns such as the example  <a href="#ex3_ttl">above</a>,
 we can answer the following question:</p>
 <p> <b>Question (3)</b>:  which are the set of virtual links between two similar or equivalent instances of unlike types in different RDF datasets?</p> 
<p>To  answer this question, the SPARQL query template 3 (<a href="#q3">SQ<sub>3</sub></a>) below can be executed. For example, 
 we can retrieve the virtual link illustrated in <a href="#fig3">Fig. 2</a> by executing <a href="#q3">SQ<sub>3</sub></a> on the <a href="http://biosoda.expasy.org:8890/sparql">SPARQL endpoint here</a>. 
 </p>

<pre class="query" id="q3">
prefix void:    &lt;http://rdfs.org/ns/void#&gt;
prefix bioquery: &lt;http://purl.org/query/bioquery#&gt;
prefix voidext:&lt;http://purl.org/query/voidext#&gt;
prefix dcterms: &lt;http://purl.org/dc/terms/&gt;

SELECT distinct ?links ?source_dataset1_name ?target_dataset2_name ?sharedType
  ?resourceMapping ?source_endpoint ?target_endpoint{
  
 #values(?dataset1){ (bioquery:EBI) }
 #values(?dataset2){ (bioquery:UNIPROT) }

 ?links a voidext:ComplexLinkSet.
 ?links void:target ?dataset1, ?dataset2 .
 ?links voidext:intersectAt ?points;
        void:target ?target_db.
 ?target_db dcterms:title ?target_dataset2_name;
           void:sparqlEndpoint ?target_endpoint.
 ?points voidext:sharedInstanceType  ?sharedType .
 ?points void:subset ?source_db .
 ?source_db dcterms:title ?source_dataset1_name;
            void:sparqlEndpoint ?source_endpoint.

 optional{   ?links voidext:recommendedMapping ?points.
             ?points voidext:resourceMapping  ?resourceMapping}
 filter(?source_db != ?target_db)        
                         
} order by ?links

#<a href="http://biosoda.expasy.org:8890/sparql?default-graph-uri=&query=prefix+void%3A++++%3Chttp%3A%2F%2Frdfs.org%2Fns%2Fvoid%23%3E%0D%0Aprefix+bioquery%3A+%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fbioquery%23%3E%0D%0Aprefix+voidext%3A%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fvoidext%23%3E%0D%0Aprefix+dcterms%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E%0D%0A%0D%0ASELECT+distinct+%3Flinks+%3Fsource_dataset1_name+%3Ftarget_dataset2_name+%3FsharedType++%3FresourceMapping+%3Fsource_endpoint+%3Ftarget_endpoint%7B%0D%0A++%0D%0A+%23values%28%3Fdataset1%29%7B+%28bioquery%3AEBI%29+%7D%0D%0A+%23values%28%3Fdataset2%29%7B+%28bioquery%3AUNIPROT%29+%7D%0D%0A%0D%0A+%3Flinks+a+voidext%3AComplexLinkSet.%0D%0A+%3Flinks+void%3Atarget+%3Fdataset1%2C+%3Fdataset2+.%0D%0A+%3Flinks++voidext%3AintersectAt+%3Fpoints%3B%0D%0A++++++++++++void%3Atarget+%3Ftarget_db.%0D%0A%3Ftarget_db+dcterms%3Atitle+%3Ftarget_dataset2_name%3B%0D%0A++++++++++++++++++++void%3AsparqlEndpoint+%3Ftarget_endpoint.%0D%0A+%3Fpoints+voidext%3AsharedInstanceType++%3FsharedType+.%0D%0A+%3Fpoints+void%3Asubset+%3Fsource_db+.%0D%0A+%3Fsource_db+dcterms%3Atitle+%3Fsource_dataset1_name%3B%0D%0A++++++++++++++++++++void%3AsparqlEndpoint+%3Fsource_endpoint.%0D%0A%0D%0A+optional%7B+++%3Flinks+voidext%3ArecommendedMapping+%3Fpoints.%0D%0A++++++++++++%3Fpoints+voidext%3AresourceMapping++%3FresourceMapping%7D%0D%0A+%0D%0Afilter%28%3Fsource_db+%21%3D+%3Ftarget_db%29++++++++%0D%0A+++++++++++++++++++++++++%0D%0A%7D+order+by+%3Flinks&should-sponge=&format=text%2Fhtml&timeout=0&debug=on"><b>Click here to execute this query over our exemplar dataset.</b></a>
 </pre>
<p> 



<p id="ex4"><b>Example 4: complex links between datasets composed of two link predicates.</b></p>

<p>
It is often preferable or only possible to define a VL between two datasets if we know the two link predicates from each dataset 
--- i.e. a complex virtual link. This is because a complex VL is required whenever the matched subject or object of predicates in different datasets are 
not typed (i.e. missing <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> assertions) or the matched object is a literal. 
Furthermore, depending on the aim of the virtual link, one can prefer to describe the virtual link according to link predicates instead of instance types 
for the case where both virtual link descriptions are possible. 
<a href="#fig4">Fig. 3</a> exemplifies a complex VL between the DrugBank and EBI RDF datasets.
</p>

<div  align="center">
<figure id="fig4">
<p><img src="images/fig3.png" class="imagedesc2"/>
<figcaption><a href="#fig4">Figure 3</a>. A virtual link between datasets based on similar IRIs of different types.</figcaption>
</figure>
</div>

The  <a href="https://www.w3.org/TR/turtle/">RDF 1.1 Turtle</a> serialisation of <a href="#ex4">Example 4</a> 
according to VoIDext vocabulary is defined <a href="#ex4_ttl">below</a>. This serialisation also shows that the link is between the DrugBank dataset
and a subset of the EBI dataset about rare diseases.
When the virtual link is stated between the link predicate's subject/object in a first dataset (e.g. EBI) and the link predicate's subject/object from a second dataset (e.g. UniProtKB)
such as illustrated in <a href="#fig4">Fig. 3</a>, we classify this virtual link as a <a href="#ComplexLinkSet">complex link set</a>. Note that the link predicate must
not be the <a href="https://www.w3.org/TR/rdf-schema/#ch_type">rdf:type</a> predicate. 
 
<pre class="example" id="ex4_ttl">
bioquery:DRUGBANK_EBI-ORDO a void:Linkset;
            void:subjectsTarget bioquery:DRUGBANK;
            rdfs:label "The link predicate description from drugbank dataset to the ORDO/EBI rare diseases dataset.";
            rdfs:comment "It is a simple virtual link  from the drugbank dataset to the ORDO/EBI rare diseases dataset
                          that is part of the bioquery:DRUGBANK_EBI-ORDO_VL complex virtual link.";
            void:objectsTarget bioquery:EBI_ORDO;
            void:linkPredicate drugbank:swissprotId;
            voidext:linkPredicateDomain drugbank:targets;
            void:subset bioquery:DRUGBANK.   
             
bioquery:EBI-ORDO_DRUGBANK a void:Linkset;
            rdfs:label "The link predicate description from ORDO/EBI rare diseases dataset to the drugbank dataset.";
            rdfs:comment "It is a simple virtual link  from ORDO/EBI rare diseases dataset to the drugbank dataset 
                           that is part of the bioquery:DRUGBANK_EBI-ORDO_VL complex virtual link.";
            void:objectsTarget bioquery:DRUGBANK;
            void:subjectsTarget bioquery:EBI_ORDO;
            void:linkPredicate oboowl:hasDbXref;
            voidext:linkPredicateRange xsd:string ;
            voidext:resourceMapping '''?g &lt;http://www.geneontology.org/formats/oboInOwl#hasDbXref&gt; ?i.
 BIND( IRI(CONCAT("http://bio2rdf.org/uniprot:",STRAFTER(?i,"SwissProt:"))) as ?NEW_IRI)
 FILTER (CONTAINS(?i, "SwissProt:" ))''';
            void:subset bioquery:EBI_ORDO.

 bioquery:DRUGBANK_EBI-ORDO_VL a voidext:ComplexLinkSet;
            rdfs:label "Virtual link for rare diseases (ORDO/EBI dataset) and drug targets (drugbank dataset).";
            rdfs:comment "Virtual link between the Orphanet rare disease terms stored as a subset in the EBI RDF
               store and the drug targets in DrugBank dataset. They have in common swissprot identifiers but they
               are represented in a different way. One is a string and another one an URI both of them containing
               a swissprot identifier.";
            void:target bioquery:DRUGBANK;
            void:target bioquery:EBI_ORDO;
            voidext:intersectAt bioquery:EBI-ORDO_DRUGBANK ;
            voidext:intersectAt bioquery:DRUGBANK_EBI-ORDO ;
            voidext:intersectionType voidext:OBJECT_OBJECT ;
            voidext:recommendedMapping bioquery:EBI-ORDO_DRUGBANK . 

bioquery:EBI a void:Dataset.
bioquery:DRUGBANK a void:Dataset.

bioquery:ORDO sd:name &lt;http://rdf.ebi.ac.uk/dataset/ordo&gt;;
            a sd:Graph.
bioquery:ORDO_2_6 sd:name &lt;http://rdf.ebi.ac.uk/dataset/ordo/2.6&gt;;
            a sd:Graph.
                  
bioquery:EBI_ORDO a sd:Dataset, void:Dataset;
            dcterms:title "Orphanet Rare Disease Ontology (ORDO)";
            sd:namedGraph bioquery:ORDO, bioquery:ORDO_2_6 ;
            sd:defaultGraph [
                        a sd:Graph, void:Dataset;
                        dcterms:title "EBI RDF serialisation" ];
            void:sparqlEndpoint &lt;https://www.ebi.ac.uk/rdf/services/sparql&gt;;
            void:subset bioquery:EBI.
 </pre>
 
	
 
<p>Once virtual links between instances are serialised with triple patterns such as the example  <a href="#ex4_ttl">above</a>,
 we can answer the following question:</p>
 <p> <b>Question (4)</b>: Which are the set of complex virtual links between two similar or equivalent resources that are either subject or object of different predicates in distinct RDF datasets? </p> 
<p>To  answer this question, the SPARQL query template 4 (<a href="#q4">SQ<sub>4</sub></a>) below can be executed. For example, 
 we can retrieve the virtual link illustrated in <a href="#fig4">Fig. 3</a> by executing <a href="#q4">SQ<sub>4</sub></a> on the <a href="http://biosoda.expasy.org:8890/sparql">SPARQL endpoint here</a>. 
 </p>

<pre class="query" id="q4">
prefix void:    &lt;http://rdfs.org/ns/void#&gt;
prefix bioquery: &lt;http://purl.org/query/bioquery#&gt;
prefix voidext:&lt;http://purl.org/query/voidext#&gt;
prefix dcterms: &lt;http://purl.org/dc/terms/&gt;

SELECT distinct ?links ?source_dataset1_name ?target_dataset2_name ?predicate
 ?intersection_type ?subj_type ?obj_type  ?source_endpoint ?target_endpoint 
 ?resourceMapping {
  
 #values(?dataset1){ (bioquery:EBI_ORDO) }
 #values(?dataset2){ (bioquery:DRUGBANK) }

 ?links a voidext:ComplexLinkSet.
 ?links void:target ?dataset1, ?dataset2 .
 ?links  voidext:intersectAt ?points;
            voidext:intersectionType/rdfs:label ?intersection_type;
            void:target ?target_db.
?target_db dcterms:title ?target_dataset2_name;
                    void:sparqlEndpoint ?target_endpoint.
 ?points void:linkPredicate ?predicate .
 ?points void:subset ?source_db .
 ?source_db dcterms:title ?source_dataset1_name;
                    void:sparqlEndpoint ?source_endpoint.
optional{ ?points voidext:linkPredicateDomain ?subj_type}
optional{ ?points voidext:linkPredicateRange ?obj_type.}
optional{ ?links voidext:recommendedMapping ?points.
               ?points voidext:resourceMapping  ?resourceMapping}
 
filter(?source_db != ?target_db)        
                         
} order by ?links

#<a href="http://biosoda.expasy.org:8890/sparql?default-graph-uri=&query=prefix+void%3A++++%3Chttp%3A%2F%2Frdfs.org%2Fns%2Fvoid%23%3E%0D%0Aprefix+bioquery%3A+%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fbioquery%23%3E%0D%0Aprefix+voidext%3A%3Chttp%3A%2F%2Fpurl.org%2Fquery%2Fvoidext%23%3E%0D%0Aprefix+dcterms%3A+%3Chttp%3A%2F%2Fpurl.org%2Fdc%2Fterms%2F%3E%0D%0A%0D%0ASELECT+distinct+%3Flinks+%3Fsource_dataset1_name+%3Ftarget_dataset2_name+%3Fpredicate+%3Fintersection_type+%3Fsubj_type+%3Fobj_type++%3Fsource_endpoint+%3Ftarget_endpoint+%3FresourceMapping+%7B%0D%0A++%0D%0A+%23values%28%3Fdataset1%29%7B+%28bioquery%3AEBI_ORDO%29+%7D%0D%0A+%23values%28%3Fdataset2%29%7B+%28bioquery%3ADRUGBANK%29+%7D%0D%0A%0D%0A+%3Flinks+a+voidext%3AComplexLinkSet.%0D%0A+%3Flinks+void%3Atarget+%3Fdataset1%2C+%3Fdataset2+.%0D%0A+%3Flinks++voidext%3AintersectAt+%3Fpoints%3B%0D%0A++++++++++++voidext%3AintersectionType%2Frdfs%3Alabel+%3Fintersection_type%3B%0D%0A++++++++++++void%3Atarget+%3Ftarget_db.%0D%0A%3Ftarget_db+dcterms%3Atitle+%3Ftarget_dataset2_name%3B%0D%0A++++++++++++++++++++void%3AsparqlEndpoint+%3Ftarget_endpoint.%0D%0A+%3Fpoints+void%3AlinkPredicate+%3Fpredicate+.%0D%0A+%3Fpoints+void%3Asubset+%3Fsource_db+.%0D%0A+%3Fsource_db+dcterms%3Atitle+%3Fsource_dataset1_name%3B%0D%0A++++++++++++++++++++void%3AsparqlEndpoint+%3Fsource_endpoint.%0D%0Aoptional%7B+%3Fpoints+voidext%3AlinkPredicateDomain+%3Fsubj_type%7D%0D%0Aoptional%7B+%3Fpoints+voidext%3AlinkPredicateRange+%3Fobj_type.%7D%0D%0Aoptional%7B+%3Flinks+voidext%3ArecommendedMapping+%3Fpoints.%0D%0A+++++++++++++++%3Fpoints+voidext%3AresourceMapping++%3FresourceMapping%7D%0D%0A+%0D%0Afilter%28%3Fsource_db+%21%3D+%3Ftarget_db%29++++++++%0D%0A+++++++++++++++++++++++++%0D%0A%7D+order+by+%3Flinks&should-sponge=&format=text%2Fhtml&timeout=0&debug=on"><b>Click here to execute this query over our exemplar dataset.</b></a>
 </pre>

<br>

<h3 id="bioquery" class="list">A real use case: <a href="https://github.com/biosoda/bioquery">Bioquery project</a> <span class="backlink"> back to <a href="#toc">ToC</a></span></h3>
<p> <a href="#fig5">Figure 4</a> illustrates virtual links among UniProt, Bgee and OMA datasets.
  For example, OMA and Bgee describe complementary information about common genes
(instances of the <a href="http://qfo.github.io/OrthologyOntology/#Gene">orth:Gene</a> class),
 as well as taxa (instances of the <a href="https://www.uniprot.org/core/#http://purl.uniprot.org/core/Taxon">up:Taxon</a> class),
  both of which can serve as virtual links to connect the two data sources. 
Below an example by using the <a href="https://www.w3.org/TR/turtle/">Turtle RDF syntax</a> of how to describe shared instances of the same class
 in different datasets with VoIDext terms. 
In this example, OMA and Bgee datasets share the same instance Internationalized Resource Identifiers (IRIs). 
Indeed, OMA instances are reused as part of the Bgee RDF graph rather than creating new Bgee ones. </p>

 <pre class="example" id="fig5">
  bioquery:OMA_BGEE_2 a <a href="#SharedInstanceSet">voidext:SharedInstanceSet</a>; #rdfs:subClassOf <a href="#VirtualLinks">voidext:VirtualLinks</a> .
            <a href="#http://rdfs.org/ns/void#target">void:target</a> bioquery:OMA;
            <a href="#http://rdfs.org/ns/void#target">void:target</a> bioquery:BGEE;
            <a href="#sharedInstanceType">voidext:sharedInstanceType</a> <a href="http://qfo.github.io/OrthologyOntology/#Gene">orth:Gene</a>.
  
  bioquery:OMA_BGEE_3 a <a href="#SharedInstanceSet">voidext:SharedInstanceSet</a>;
             <a href="#http://rdfs.org/ns/void#target">void:target</a> bioquery:OMA;
             <a href="#http://rdfs.org/ns/void#target">void:target</a> bioquery:BGEE;
             <a href="#sharedInstanceType">voidext:sharedInstanceType</a> <a href="https://www.uniprot.org/core/#http://purl.uniprot.org/core/Taxon">up:Taxon</a>.           
 </pre>

<div  align="center">     
<figure id="fig5">
<p><img src="images/fig5.png" class="imagedesc"/>
<figcaption><a href="#fig5">Figure 4</a> Example of virtual links among UniProt, OMA and Bgee datasets.</figcaption>
</figure>
</div>

<p>Thus, <a href="http://qfo.github.io/OrthologyOntology/#Gene">orth:Gene</a> instances are intersection nodes (i.e. virtual links) between the Bgee and OMA graphs. 
<a href="#fig5">Figure 4</a> illustrates a shared <a href="http://qfo.github.io/OrthologyOntology/#Gene">orth:Gene</a>
 instance between OMA and Bgee graphs as a grayscale filled circle. </p>

 <p>Cross-reference IRIs serve as virtual links among the data stores. Concretely, let us consider 
 cross-references to <a href="https://www.ensembl.org/index.html">Ensembl</a> genes. On the one hand, the Ensembl gene IRI is assigned to 
 <a href="https://www.uniprot.org/core/#http://purl.uniprot.org/core/transcribedFrom">up:transcribedFrom</a>
 OWL object property in UniProt RDF store. This IRI is illustrated as a filled black circle in <a href="#fig5">Figure 4</a>.
 On the other hand, we reuse the same IRI as value of the lscr:xrefEnsemblGene OWL annotation property in the Bgee and OMA RDF graphs. This example is better
 depicted in the RDF serialisation <a href="#ex5_ttl">below</a> where this virtual link is defined as an instance of
  <a href="#ComplexLinkSet">voidext:ComplexLinkSet</a> that is a subclass of <a href="#VirtualLinks">voidext:VirtualLinks</a>.
 In addition, we can mention the rdfs:label and skos:prefLabel properties that assert the same gene names (e.g. "HBB") 
 to an instance of <a href="http://qfo.github.io/OrthologyOntology/#Gene">orth:Gene</a> in the Bgee graph and 
  <a href="https://www.uniprot.org/core/#http://purl.uniprot.org/core/Gene">up:Gene</a> in the UniProt RDF graph, respectively. In <a href="#fig5">Figure 4</a>,
  these literals are represented as rectangles. 
</p>

<p>The example <a href="#ex5_ttl">below</a> defines with the <a href="https://www.w3.org/TR/turtle/">Turtle RDF syntax</a> some of the instances shown 
in <a href="#fig5">Figure 4</a>.
This example illustrates how to instantiate virtual links of type <a href="#ComplexLinkSet">voidext:ComplexLinkSet</a> with the VoIDext RDF schema.
</p>
<div>	
<pre class="example" id="ex5_ttl">
bioquery:UNIPROT_OMA_2 a <a href="#ComplexLinkSet">voidext:ComplexLinkSet</a>; ### The filled gray circle in <a href="#fig5">Figure 4</a>
			<a href="#http://rdfs.org/ns/void#target">void:target</a> bioquery:OMA;
			<a href="#http://rdfs.org/ns/void#target">void:target</a> bioquery:UNIPROT;
			<a href="#intersectAt">voidext:intersectAt</a> bioquery:UNIPROT_EBI-ENSEMBL ;
			<a href="#intersectAt">voidext:intersectAt</a> bioquery:OMA_EBI-ENSEMBL ;
			<a href="#intersectionType">voidext:intersectionType</a> <a href="#OBJECT_OBJECT">voidext:OBJECT_OBJECT</a> .

bioquery:UNIPROT_EBI-ENSEMBL a  <a href="#http://rdfs.org/ns/void#Linkset">void:Linkset</a>; ### The filled black circle in <a href="#fig5">Figure 4</a>
             <a href="#http://rdfs.org/ns/void#subjectsTarget">void:subjectsTarget</a> bioquery:UNIPROT;
             <a href="#http://rdfs.org/ns/void#objectsTarget">void:objectsTarget</a> bioquery:EBI;
             <a href="#http://rdfs.org/ns/void#linkPredicate">void:linkPredicate</a> <a href="https://www.uniprot.org/core/#http://purl.uniprot.org/core/transcribedFrom">up:transcribedFrom</a>;
             <a href="#linkPredicateDomain">voidext:linkPredicateDomain</a> <a href="https://www.uniprot.org/core/#http://purl.uniprot.org/core/Transcript_Resource">up:Transcript_Resource</a>;
             <a href="#linkPredicateRange">voidext:linkPredicateRange</a> <a href="http://www.ontobee.org/ontology/SO?iri=http://purl.obolibrary.org/obo/SO_0000704">obo:SO_0000704</a>;
			 <a href="#linkPredicateRange">void:subset</a> bioquery:UNIPROT.

bioquery:OMA_EBI-ENSEMBL a <a href="#http://rdfs.org/ns/void#Linkset">void:Linkset</a>; ### The white circle in <a href="#fig5">Figure 4</a>
             <a href="#http://rdfs.org/ns/void#subjectsTarget">void:subjectsTarget</a> bioquery:OMA;
             <a href="#http://rdfs.org/ns/void#objectsTarget">void:objectsTarget</a> bioquery:EBI;
             <a href="#http://rdfs.org/ns/void#linkPredicate">void:linkPredicate</a> lscr:xrefEnsemblGene;
             <a href="#linkPredicateDomain">voidext:linkPredicateDomain</a> <a href="http://qfo.github.io/OrthologyOntology/#Gene">orth:Gene</a>;
             <a href="#linkPredicateRange">voidext:linkPredicateRange</a> <a href="http://www.ontobee.org/ontology/SO?iri=http://purl.obolibrary.org/obo/SO_0000704">obo:SO_0000704</a>;
   			 <a href="#linkPredicateRange">void:subset</a> bioquery:OMA.
	
bioquery:OMA a  <a href="#http://rdfs.org/ns/void#Dataset">void:Dataset</a>.
bioquery:UNIPROT a  <a href="#http://rdfs.org/ns/void#Dataset">void:Dataset</a>.
bioquery:EBI a  <a href="#http://rdfs.org/ns/void#Dataset">void:Dataset</a>.		
</pre>
</div>	
<p>
For further instantiation examples serialised with Turtle syntax, please refer to the <a href="http://purl.org/query/bioquery">BioQuery RDF federation metadata file</a>. 
</p>
<br>	

<h3 id="voidext_void" class="list">VoIDext <i>vs</i> VoID: main changes <span class="backlink"> back to <a href="#toc">ToC</a></span></h3>

<p>We built the VoIDext TBox based on the <a href="https://www.w3.org/TR/rdf-schema/">RDF schema 1.1</a> and the already existing <a 
href="http://vocab.deri.ie/void">VoID RDF schema vocabulary</a>.
Unlike VoID, we stated the <a href="#http://rdfs.org/ns/void#Linkset">void:Linkset</a> class as a subclass of the new <a href="#SimpleLinkSet">voidext:SimpleLinkSet</a> class instead of the
   <a href="#Dataset">void:Dataset</a> class as it was previously stated. The <a href="#SimpleLinkSet">voidext:SimpleLinkSet</a> is a class to represent the simple virtual links and 
   <a href="#SimpleLinkSet">voidext:SimpleLinkSet</a> &#8849; <a href="#Dataset">void:Dataset</a>, where the symbol &#8849; reads as "is subsumed by". Then, we can infer 
   that <a href="#http://rdfs.org/ns/void#Linkset">void:Linkset</a> &#8849; <a href="#Dataset">void:Dataset</a> what makes VoID instances (ABox) fully compatible with the VoIDext schema. In 
   addition to the <a href="#http://rdfs.org/ns/void#Linkset">void:Linkset</a> term,  in spite of the fact that we modified <a href="#http://rdfs.org/ns/void#target">void:target</a>
   , <a href="#http://rdfs.org/ns/void#subjectsTarget">void:subjectsTarget</a> and 
   <a href="#http://rdfs.org/ns/void#objectsTarget">void:objectsTarget</a> property domains  from <a href="#http://rdfs.org/ns/void#Linkset">void:Linkset</a> to <a href="#VirtualLink">voidext:VirtualLink</a>, 
   the VoIDext is still backward compatible with any VoID-based ABox since <a href="#http://rdfs.org/ns/void#Linkset">void:Linkset</a> &#8849; <a href="#VirtualLink">voidext:VirtualLink</a>. 
   The <a href="#http://rdfs.org/ns/void#target">void:target</a> is assigned with one of the two datasets linked by the <i>virtual link</i> where <a href="#http://rdfs.org/ns/void#subjectsTarget">void:subjectsTarget</a> &#8849;
    <a href="#http://rdfs.org/ns/void#target">void:target</a> and <a href="#http://rdfs.org/ns/void#objectsTarget">void:objectsTarget</a> &#8849; <a href="#http://rdfs.org/ns/void#target">void:target</a>. 
    The <a href="#http://rdfs.org/ns/void#subjectsTarget">void:subjectsTarget</a>/<a href="#http://rdfs.org/ns/void#objectsTarget">void:objectsTarget</a> 
    property asserts as its value the dataset that describes the subjects/objects of triples contained in the virtual link. 
    By asserting these sub-target properties, we can state the subject-object direction of the links explicitly. <a href="#fig44">Fig. 5</a> illustrates VoIDext main concepts 
    and an example of a complex link involving two link predicates. 
</p>
<div  align="center">
<figure id="fig44">
<p><img src="images/fig4.png" class="imagedesc2"/>
<figcaption><a href="#fig44">Figure 5</a>. A portion of the VoIDext terminological and assertion boxes.</figcaption>
</figure>
</div>

	
